"""
Manim service for executing animation code and generating video files
"""
import os
import sys
import tempfile
import subprocess
import uuid
import asyncio
import base64
import time
from typing import Optional, Tuple
from pathlib import Path
from utils.config import settings
from utils.file_utils import ensure_directory_exists, generate_unique_filename
from fastapi.responses import StreamingResponse


class ManimService:
    """Service for executing Manim code and generating animations"""
    
    def __init__(self):
        self.output_dir = settings.MANIM_OUTPUT_DIR
        self.quality = settings.MANIM_QUALITY
        self.frame_rate = settings.MANIM_FRAME_RATE
        self.video_map = {}  # request_id -> video_path
        self.no_video_requests = set()  # request_ids that won't have videos
        
        # Ensure output directory exists
        ensure_directory_exists(self.output_dir)
    
    async def generate_animation(self, manim_code: str) -> Optional[str]:
        """
        Execute Manim code and generate animation video
        
        Args:
            manim_code: Python code containing Manim animation
            
        Returns:
            Path to the generated video file, or None if failed
        """
        if not manim_code.strip():
            return None
        
        try:
            # Create a temporary file for the Manim code
            temp_file = await self._create_temp_manim_file(manim_code)
            
            # Execute the Manim code
            video_path = await self._execute_manim(temp_file)
            
            # Clean up temporary file
            os.unlink(temp_file)
            
            return video_path
            
        except Exception as e:
            print(f"Manim execution failed: {str(e)}")
            return None
        
    async def generate_animation_base64(self, manim_code: str, class_name: str = "ConceptAnimation") -> str:
        """
        Execute Manim code, return base64-encoded video, and delete temp files.
        """
        temp_file = await self._create_temp_manim_file(manim_code)
        video_path = await self._execute_manim(temp_file)
        os.unlink(temp_file)
        if video_path and os.path.exists(video_path):
            with open(video_path, "rb") as f:
                video_bytes = f.read()
            os.unlink(video_path)
            return base64.b64encode(video_bytes).decode("utf-8")
        return None
    
    async def generate_animation_stream(self, manim_code: str, class_name: str = "ConceptAnimation"):
        """
        Generate Manim animation and stream the video as a response (no permanent file)
        """
        # Create temp directory in current working directory
        temp_dir = os.path.join(os.getcwd(), "temp_manim")
        os.makedirs(temp_dir, exist_ok=True)
        
        temp_py_path = os.path.join(temp_dir, f"animation_{uuid.uuid4().hex[:8]}.py")
        temp_video_path = os.path.join(temp_dir, f"video_{uuid.uuid4().hex[:8]}.mp4")
        
        try:
            # Write the Manim code
            with open(temp_py_path, 'w', encoding='utf-8') as f:
                f.write(manim_code)
            
            # Run Manim
            cmd = [
                sys.executable, "-m", "manim",
                "-pql",
                "--media_dir", temp_dir,
                temp_py_path,
                class_name
            ]
            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode != 0:
                print(result.stderr)
                raise RuntimeError("Manim execution failed")
            
            # Find the generated video file
            mp4_files = [f for f in os.listdir(temp_dir) if f.endswith('.mp4')]
            if not mp4_files:
                raise RuntimeError("No video file generated by Manim")
            
            video_path = os.path.join(temp_dir, mp4_files[0])
            video_file = open(video_path, 'rb')
            return StreamingResponse(video_file, media_type="video/mp4")
            
        finally:
            # Clean up temporary files
            try:
                if os.path.exists(temp_py_path):
                    os.remove(temp_py_path)
            except:
                pass
    
    async def render_and_store_video(self, manim_code: str, class_name: str, request_id: str):
        print(f"[ManimService] render_and_store_video called with request_id: {request_id}")
        print(f"[ManimService] Class name: {class_name}")
        
        temp_dir = os.path.join(os.getcwd(), "temp_manim")
        os.makedirs(temp_dir, exist_ok=True)
        print(f"[ManimService] Using temp_dir: {temp_dir}")
        
        temp_py_path = os.path.join(temp_dir, f"animation_{request_id}.py")
        try:
            with open(temp_py_path, 'w', encoding='utf-8') as f:
                f.write(manim_code)
            print(f"[ManimService] Wrote Manim code to: {temp_py_path}")
            
            rel_py_path = os.path.basename(temp_py_path)
            cmd = [
                sys.executable, "-m", "manim",
                "-pql",
                "--media_dir", ".",
                rel_py_path,
                class_name
            ]
            print(f"[ManimService] Running Manim subprocess: {' '.join(cmd)}")
            try:
                result = await asyncio.wait_for(
                    asyncio.get_event_loop().run_in_executor(
                        None,
                        lambda: subprocess.run(
                            cmd, 
                            capture_output=True, 
                            text=True,
                            env=os.environ.copy(),
                            cwd=temp_dir,
                            timeout=300
                        )
                    ),
                    timeout=130
                )
            except asyncio.TimeoutError:
                print(f"[ManimService] Manim execution timed out for {request_id}")
                result = type('MockResult', (), {
                    'returncode': -1,
                    'stdout': '',
                    'stderr': 'Execution timed out'
                })()
            except Exception as e:
                print(f"[ManimService] Manim execution failed with exception: {e}")
                result = type('MockResult', (), {
                    'returncode': -1,
                    'stdout': '',
                    'stderr': f'Execution failed: {str(e)}'
                })()
            print(f"[ManimService] Subprocess result: {result.returncode}")
            print(f"[ManimService] Subprocess stdout: {result.stdout}")
            print(f"[ManimService] Subprocess stderr: {result.stderr}")
            
            if result.returncode != 0:
                print(f"[ManimService] Manim execution failed with return code: {result.returncode}")
                print(f"[ManimService] Generated code that failed:")
                with open(temp_py_path, 'r', encoding='utf-8') as f:
                    print(f.read())
                # Check for partial videos
                partial_videos = []
                for root, dirs, files in os.walk(temp_dir):
                    for file in files:
                        if file.endswith('.mp4'):
                            partial_videos.append(os.path.join(root, file))
                if partial_videos:
                    print(f"[ManimService] Found partial videos despite error: {partial_videos}")
                    largest_video = max(partial_videos, key=lambda x: os.path.getsize(x))
                    print(f"[ManimService] Using largest partial video: {largest_video}")
                    self.video_map[request_id] = largest_video
                    return (largest_video, None, manim_code)
                # Return error and code for debugging
                return (None, result.stderr, manim_code)
            # Normal video search
            print(f"[ManimService] Files in temp_dir after execution: {os.listdir(temp_dir)}")
            mp4_files = []
            for root, dirs, files in os.walk(temp_dir):
                for file in files:
                    if file.endswith('.mp4'):
                        mp4_files.append(os.path.join(root, file))
            print(f"[ManimService] Found mp4 files: {mp4_files}")
            if mp4_files:
                mp4_files.sort(key=lambda x: os.path.getmtime(x), reverse=True)
                current_time = time.time()
                recent_videos = [f for f in mp4_files if current_time - os.path.getmtime(f) < 60]
                if recent_videos:
                    video_path = recent_videos[0]
                    self.video_map[request_id] = video_path
                    print(f"[ManimService] Recent video mapped: {request_id} -> {video_path}")
                    print(f"[ManimService] Video file size: {os.path.getsize(video_path)} bytes")
                    return (video_path, None, manim_code)
                else:
                    video_path = mp4_files[0]
                    self.video_map[request_id] = video_path
                    print(f"[ManimService] Video mapped: {request_id} -> {video_path}")
                    print(f"[ManimService] Video file size: {os.path.getsize(video_path)} bytes")
                    return (video_path, None, manim_code)
            else:
                print(f"[ManimService] No .mp4 files found in {temp_dir} after execution!")
                
                # Try creating a more substantial fallback Manim scene
                print(f"[ManimService] Creating substantial fallback Manim scene...")
                
                # Extract the original question from the manim_code if possible
                # Look for any text that might indicate what the user asked about
                question_hint = "your question"
                if "Dijkstra" in manim_code or "dijkstra" in manim_code.lower():
                    question_hint = "Dijkstra's Algorithm"
                elif "sort" in manim_code.lower():
                    question_hint = "Sorting Algorithm"
                elif "graph" in manim_code.lower():
                    question_hint = "Graph Algorithm"
                elif "tree" in manim_code.lower():
                    question_hint = "Tree Data Structure"
                elif "search" in manim_code.lower():
                    question_hint = "Search Algorithm"
                elif "path" in manim_code.lower():
                    question_hint = "Path Finding"
                elif "sort" in manim_code.lower():
                    question_hint = "Sorting"
                elif "math" in manim_code.lower() or "equation" in manim_code.lower():
                    question_hint = "Mathematical Concept"
                elif "physics" in manim_code.lower():
                    question_hint = "Physics Concept"
                elif "chemistry" in manim_code.lower():
                    question_hint = "Chemistry Concept"
                
                simple_manim_code = f'''
from manim import *

class {class_name}(Scene):
    def construct(self):
        # Create a substantial educational animation related to the user's question
        title = Text("{question_hint}", font_size=36, color=BLUE)
        self.play(Write(title))
        self.wait(0.5)
        
        # Step 1: Show initial state
        step1_text = Text("Step 1: Understanding the Problem", font_size=24, color=WHITE).next_to(title, DOWN)
        self.play(Write(step1_text))
        self.wait(0.5)
        
        # Create multiple geometric shapes with labels
        circle = Circle(color=RED, radius=0.4).shift(LEFT * 3 + UP)
        circle_label = Text("A", font_size=20, color=WHITE).next_to(circle, DOWN)
        circle_group = VGroup(circle, circle_label)
        
        square = Square(color=GREEN, side_length=0.8).shift(RIGHT * 3 + UP)
        square_label = Text("B", font_size=20, color=WHITE).next_to(square, DOWN)
        square_group = VGroup(square, square_label)
        
        triangle = Triangle(color=YELLOW).scale(0.4).shift(UP * 2)
        triangle_label = Text("C", font_size=20, color=WHITE).next_to(triangle, DOWN)
        triangle_group = VGroup(triangle, triangle_label)
        
        # Animate shapes appearing one by one
        self.play(Create(circle_group))
        self.wait(0.3)
        self.play(Create(square_group))
        self.wait(0.3)
        self.play(Create(triangle_group))
        self.wait(0.5)
        
        # Step 2: Show connections
        step2_text = Text("Step 2: Creating Connections", font_size=24, color=WHITE).next_to(step1_text, DOWN)
        self.play(Write(step2_text))
        self.wait(0.3)
        
        # Add connecting lines with animations
        line1 = Line(circle.get_center(), square.get_center(), color=WHITE, stroke_width=3)
        line2 = Line(square.get_center(), triangle.get_center(), color=WHITE, stroke_width=3)
        line3 = Line(triangle.get_center(), circle.get_center(), color=WHITE, stroke_width=3)
        
        self.play(Create(line1))
        self.wait(0.2)
        self.play(Create(line2))
        self.wait(0.2)
        self.play(Create(line3))
        self.wait(0.5)
        
        # Step 3: Show transformations
        step3_text = Text("Step 3: Processing Data", font_size=24, color=WHITE).next_to(step2_text, DOWN)
        self.play(Write(step3_text))
        self.wait(0.3)
        
        # Animate transformations with different effects
        self.play(
            circle.animate.scale(1.3).set_color(PURPLE),
            circle_label.animate.set_color(PURPLE),
            run_time=1
        )
        self.wait(0.3)
        
        self.play(
            square.animate.rotate(PI/6).set_color(ORANGE),
            square_label.animate.set_color(ORANGE),
            run_time=1
        )
        self.wait(0.3)
        
        self.play(
            triangle.animate.scale(1.2).set_color(PINK),
            triangle_label.animate.set_color(PINK),
            run_time=1
        )
        self.wait(0.5)
        
        # Step 4: Show data flow
        step4_text = Text("Step 4: Data Flow", font_size=24, color=WHITE).next_to(step3_text, DOWN)
        self.play(Write(step4_text))
        self.wait(0.3)
        
        # Animate data flow along the lines
        data_dot1 = Dot(color=BLUE, radius=0.1).move_to(circle.get_center())
        data_dot2 = Dot(color=BLUE, radius=0.1).move_to(square.get_center())
        data_dot3 = Dot(color=BLUE, radius=0.1).move_to(triangle.get_center())
        
        self.play(Create(data_dot1))
        self.play(data_dot1.animate.move_to(square.get_center()), run_time=1)
        self.play(Create(data_dot2))
        self.play(data_dot2.animate.move_to(triangle.get_center()), run_time=1)
        self.play(Create(data_dot3))
        self.play(data_dot3.animate.move_to(circle.get_center()), run_time=1)
        self.wait(0.5)
        
        # Step 5: Final result
        step5_text = Text("Step 5: Final Result", font_size=24, color=WHITE).next_to(step4_text, DOWN)
        self.play(Write(step5_text))
        self.wait(0.3)
        
        # Highlight all elements
        self.play(
            VGroup(circle_group, square_group, triangle_group).animate.set_color(GREEN),
            VGroup(line1, line2, line3).animate.set_color(GREEN).set_stroke_width(6),
            VGroup(data_dot1, data_dot2, data_dot3).animate.set_color(GREEN)
        )
        self.wait(1)
        
        # Final summary
        summary = Text("Algorithm Complete!", font_size=28, color=GREEN)
        summary.next_to(title, UP)
        self.play(Write(summary))
        self.wait(1.5)
        
        # Clean up with fade out
        all_elements = VGroup(
            title, step1_text, step2_text, step3_text, step4_text, step5_text,
            circle_group, square_group, triangle_group,
            line1, line2, line3, data_dot1, data_dot2, data_dot3, summary
        )
        self.play(FadeOut(all_elements))
        self.wait(0.5)
'''
                
                simple_py_path = os.path.join(temp_dir, f"simple_{request_id}.py")
                with open(simple_py_path, 'w', encoding='utf-8') as f:
                    f.write(simple_manim_code)
                
                # Try the simple scene
                simple_cmd = [
                    sys.executable, "-m", "manim",
                    "-pql",
                    "--media_dir", ".",
                    os.path.basename(simple_py_path),
                    class_name
                ]
                
                try:
                    simple_result = await asyncio.wait_for(
                        asyncio.get_event_loop().run_in_executor(
                            None,
                            lambda: subprocess.run(
                                simple_cmd,
                                capture_output=True,
                                text=True,
                                cwd=temp_dir,
                                timeout=60  # 1 minute timeout for simple scene
                            )
                        ),
                        timeout=70  # Slightly longer timeout for the async wrapper
                    )
                except asyncio.TimeoutError:
                    print(f"[ManimService] Simple scene execution timed out for {request_id}")
                    simple_result = type('MockResult', (), {
                        'returncode': -1,
                        'stdout': '',
                        'stderr': 'Simple scene execution timed out'
                    })()
                except Exception as e:
                    print(f"[ManimService] Simple scene execution failed with exception: {e}")
                    simple_result = type('MockResult', (), {
                        'returncode': -1,
                        'stdout': '',
                        'stderr': f'Simple scene execution failed: {str(e)}'
                    })()
                
                print(f"[ManimService] Simple scene result: {simple_result.returncode}")
                print(f"[ManimService] Simple scene stdout: {simple_result.stdout}")
                print(f"[ManimService] Simple scene stderr: {simple_result.stderr}")
                
                # Check for generated video again
                mp4_files = []
                for root, dirs, files in os.walk(temp_dir):
                    for file in files:
                        if file.endswith('.mp4'):
                            mp4_files.append(os.path.join(root, file))
                
                if mp4_files:
                    video_path = mp4_files[0]
                    self.video_map[request_id] = video_path
                    print(f"[ManimService] Simple video mapped: {request_id} -> {video_path}")
                else:
                    # No video was generated, don't create a fake one
                    print(f"[ManimService] No video files generated by simple scene either")
                    print(f"[ManimService] Request {request_id} will not have a video")
                    # Mark this request as not having a video
                    self.no_video_requests.add(request_id)
                
        finally:
            # Clean up temporary files
            try:
                if os.path.exists(temp_py_path):
                    os.remove(temp_py_path)
                simple_py_path = os.path.join(temp_dir, f"simple_{request_id}.py")
                if os.path.exists(simple_py_path):
                    os.remove(simple_py_path)
            except Exception as e:
                print(f"[ManimService] Cleanup error: {e}")
                pass

    def get_video_path(self, request_id: str):
        return self.video_map.get(request_id)
    
    async def _create_temp_manim_file(self, manim_code: str) -> str:
        """Create a temporary Python file with the Manim code"""
        # Generate a unique class name to avoid conflicts
        class_name = f"Animation_{uuid.uuid4().hex[:8]}"
        
        # Wrap the code in a proper class if it's not already
        if "class" not in manim_code and "Scene" not in manim_code:
            # Create a basic scene class
            wrapped_code = f"""
from manim import *

class {class_name}(Scene):
    def construct(self):
        {manim_code}
"""
        else:
            # Extract the class name from existing code
            if "class" in manim_code:
                lines = manim_code.split('\n')
                for line in lines:
                    if line.strip().startswith('class ') and 'Scene' in line:
                        class_name = line.split('class ')[1].split('(')[0].strip()
                        break
            
            # Use the existing code as-is
            wrapped_code = manim_code
        
        # Create temporary file in a more accessible location
        temp_dir = os.path.join(os.getcwd(), "temp_manim")
        os.makedirs(temp_dir, exist_ok=True)
        temp_file = os.path.join(temp_dir, f"animation_{uuid.uuid4().hex[:8]}.py")
        
        with open(temp_file, 'w', encoding='utf-8') as f:
            f.write(wrapped_code)
        
        return temp_file
    
    async def _execute_manim(self, python_file: str) -> Optional[str]:
        """Execute Manim command to render the animation"""
        try:
            # Get the class name from the file
            class_name = self._extract_class_name(python_file)
            
            # Build the Manim command
            cmd = [
                sys.executable, "-m", "manim",
                "-pql",  # Preview, quality, and loop
                "--media_dir", self.output_dir,
                python_file,
                class_name
            ]
            
            # Execute the command
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=300  # 5 minute timeout - increased for complex animations
            )
            
            if result.returncode != 0:
                print(f"Manim execution error: {result.stderr}")
                return None
            
            # Find the generated video file
            video_path = self._find_generated_video(class_name)
            
            return video_path
            
        except subprocess.TimeoutExpired:
            print("Manim execution timed out")
            return None
        except Exception as e:
            print(f"Manim execution failed: {str(e)}")
            return None
    
    def _extract_class_name(self, python_file: str) -> str:
        """Extract the class name from the Python file"""
        try:
            with open(python_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Look for class definition
            lines = content.split('\n')
            for line in lines:
                if line.strip().startswith('class ') and 'Scene' in line:
                    class_name = line.split('class ')[1].split('(')[0].strip()
                    return class_name
            
            # Fallback to default
            return "Animation"
            
        except Exception:
            return "Animation"
    
    def _find_generated_video(self, class_name: str) -> Optional[str]:
        """Find the generated video file in the output directory"""
        try:
            # Manim creates nested directories like videos/filename/quality/ClassName.mp4
            videos_dir = os.path.join(self.output_dir, "videos")
            if not os.path.exists(videos_dir):
                return None
            
            # Look for MP4 files recursively in the videos directory
            for root, dirs, files in os.walk(videos_dir):
                for file in files:
                    if file.endswith('.mp4') and class_name.lower() in file.lower():
                        return os.path.join(root, file)
            
            # If not found by class name, return the most recent MP4
            mp4_files = []
            for root, dirs, files in os.walk(videos_dir):
                for file in files:
                    if file.endswith('.mp4'):
                        mp4_files.append(os.path.join(root, file))
            
            if mp4_files:
                # Sort by modification time (most recent first)
                mp4_files.sort(key=lambda x: os.path.getmtime(x), reverse=True)
                return mp4_files[0]
            
            return None
            
        except Exception as e:
            print(f"Error finding generated video: {str(e)}")
            return None
    
    def get_video_url(self, video_path: str) -> str:
        """Convert file path to URL for frontend access"""
        if not video_path:
            return ""
        
        filename = os.path.basename(video_path)
        return f"/media/{filename}"
    
    def cleanup_old_videos(self, max_age_hours: int = 24) -> None:
        """Clean up old video files"""
        from ..utils.file_utils import cleanup_old_files
        cleanup_old_files(self.output_dir, max_age_hours)
    
    def cleanup_temp_files(self) -> None:
        """Clean up temporary files"""
        temp_dir = os.path.join(os.getcwd(), "temp_manim")
        if os.path.exists(temp_dir):
            try:
                for file in os.listdir(temp_dir):
                    file_path = os.path.join(temp_dir, file)
                    try:
                        if os.path.isfile(file_path):
                            os.remove(file_path)
                    except Exception as e:
                        print(f"Failed to remove temp file {file}: {e}")
            except Exception as e:
                print(f"Failed to cleanup temp directory: {e}") 